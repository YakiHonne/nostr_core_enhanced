// ignore_for_file: constant_identifier_names, non_constant_identifier_names

import 'dart:async';
import 'dart:convert';
import 'dart:math';

import 'package:nostr_core_enhanced/core/nostr_core_repository.dart';
import 'package:nostr_core_enhanced/nostr/nostr.dart';
import 'package:nostr_core_enhanced/utils/utils.dart';

// Method constants
const REMOTE_CONNECT = 'connect';
const REMOTE_SIGN_EVENT = 'sign_event';
const PING = 'ping';
const REMOTE_PUBLIC_KEY = 'get_public_key';
const REMOTE_NIP04_ENCRYPT = 'nip04_encrypt';
const REMOTE_NIP04_DECRYPT = 'nip04_decrypt';
const REMOTE_NIP44_ENCRYPT = 'nip44_encrypt';
const REMOTE_NIP44_DECRYPT = 'nip44_decrypt';

// Regex patterns
final RegExp BUNKER_REGEX =
    RegExp(r'^bunker://([0-9a-f]{64})\??([?\\/\w:.=&%-]*)$');
final RegExp NIP05_REGEX =
    RegExp(r'^([a-z0-9._-]+)@([a-z0-9.-]+\.[a-z]{2,})$', caseSensitive: false);
final RegExp EMAIL_REGEX = RegExp(r'^[^\s@]+@[^\s@]+\.[^\s@]+$');

List<String> remoteSignerRelays = [
  'wss://relay.nsec.app',
];

enum RemoteSignerState {
  disconnected,
  connecting,
  awaitingAuth,
  connected,
  failed,
}

class BunkerPointer {
  final List<String> relays;
  final String pubkey;
  final String? secret;

  BunkerPointer({
    required this.relays,
    required this.pubkey,
    this.secret,
  });

  String toBunkerURL() {
    final uri = Uri(
      scheme: 'bunker',
      host: pubkey,
      queryParameters: {
        if (secret != null) 'secret': secret!,
        ...relays.asMap().map((_, relay) => MapEntry('relay', relay)),
      },
    );
    return uri.toString();
  }
}

class NostrConnectParams {
  final String clientPubkey;
  final List<String> relays;
  final String secret;
  final List<String>? perms;
  final String? name;
  final String? url;
  final String? image;

  NostrConnectParams({
    required this.clientPubkey,
    required this.relays,
    required this.secret,
    this.perms,
    this.name,
    this.url,
    this.image,
  });
}

class ParsedNostrConnectURI {
  final String protocol;
  final String clientPubkey;
  final NostrConnectParams params;
  final String originalString;

  ParsedNostrConnectURI({
    required this.protocol,
    required this.clientPubkey,
    required this.params,
    required this.originalString,
  });
}

class RemoteEventSigner implements EventSigner {
  // Private fields

  final Map<String, Completer<Map<String, dynamic>?>> _listeners = {};
  final Map<String, bool> _waitingForAuth = {};

  // Public fields
  final Function(String, bool)? onAuth;
  late NostrCore nc;

  late String publicKey;
  late Bip340EventSigner localSigner;
  late String bunkerPubkey;
  late List<String> relays;

  String? connectionSecret;
  String? _subscriptionId;

  bool _isOpen = false;
  int _serial = 0;
  late String _idPrefix;

  RemoteEventSigner({this.onAuth, NostrCore? nc}) {
    _idPrefix = _generateRandomId();
    if (nc != null) {
      this.nc = nc;
    } else {
      nc = NostrCore();
    }
  }

  bool get isReady => bunkerPubkey.isNotEmpty && relays.isNotEmpty;
  bool get isOpen => _isOpen;

  RemoteSignerState _connectionState = RemoteSignerState.disconnected;
  RemoteSignerState get connectionState => _connectionState;

  // Static factory methods (matching TypeScript structure)

  /// Creates a Signer using bunker information (bunker:// URL or NIP-05)
  static Future<RemoteEventSigner?> fromBunker(
    String clientSecretKey,
    BunkerPointer bunkerPointer, {
    Function(String, bool)? onAuth,
    NostrCore? nc,
  }) async {
    final signer = RemoteEventSigner(onAuth: onAuth, nc: nc);

    signer._loadSigner(
      secret: clientSecretKey,
      relays: bunkerPointer.relays,
      bunkerPubkey: bunkerPointer.pubkey,
      publicKey: '',
      connectionSecret: bunkerPointer.secret,
    );

    await signer._setupSubscription();
    final isSuccessful = await signer.connect();

    if (isSuccessful) {
      return signer;
    }

    return signer;
  }

  Future<void> generateKeysAndConnect(
      Function(String) onConnectionUrlReady) async {
    final keys = Keychain.generate();

    _loadSigner(
      secret: keys.private,
      relays: remoteSignerRelays,
      bunkerPubkey: '',
      publicKey: '',
      connectionSecret: randomizeString(10),
    );

    onConnectionUrlReady.call(getConnectionUrl());

    await nc.connectNonConnectedRelays(relays.toSet());
  }

  /// Creates a Signer using a nostrconnect:// URI generated by the client
  static Future<RemoteEventSigner?> fromURI({
    required Function(String) onConnectionUrlReady,
    Function(String, bool)? onAuth,
    int maxWait = 300000,
    NostrCore? nc,
  }) async {
    final signer = RemoteEventSigner(onAuth: onAuth, nc: nc);
    await signer.generateKeysAndConnect(onConnectionUrlReady);

    final Set<String> seenEventIds = {};
    final completer = Completer<RemoteEventSigner?>();
    Timer? timer;

    timer = Timer(Duration(milliseconds: maxWait), () {
      if (!completer.isCompleted) {
        completer.complete(null);
      }
    });

    String subscriptionId = '';
    final localSigner = signer.localSigner;

    // Setup temporary subscription to listen for connection
    subscriptionId = signer.nc.addSubscription(
      [
        Filter(
          kinds: [EventKind.REMOTE_SIGNER],
          p: [localSigner.publicKey],
        ),
      ],
      signer.relays,
      eventCallBack: (event, relay) async {
        logger.i(event.toJson());
        if (seenEventIds.contains(event.id)) return;
        seenEventIds.add(event.id);

        try {
          String? decryptedContent = await signer._decryptEventContent(
            content: event.content,
            pubkey: event.pubkey,
          );

          logger.i(decryptedContent);

          if (decryptedContent != null) {
            final response = json.decode(decryptedContent);

            if (response['result'] == 'auth_url') {
              final url = response['error'];
              if (url != null) {
                signer.onAuth?.call(url, false);
              }

              return; // wait for next event
            } else if (response['result'] == signer.connectionSecret) {
              timer?.cancel();
              signer.nc.closeRequests([subscriptionId]);

              signer.bunkerPubkey = event.pubkey;

              await signer._setupSubscription();

              if (!completer.isCompleted) {
                completer.complete(signer);
              }
            }
          }
        } catch (e) {
          logger.w('Failed to process potential connection event: $e');
        }
      },
    );

    return completer.future;
  }

  /// Parse bunker input (bunker:// URL or NIP-05 identifier)
  static BunkerPointer? parseBunkerInput(String input) {
    final match = BUNKER_REGEX.firstMatch(input);

    if (match != null) {
      try {
        final pubkey = match.group(1)!;
        final queryString = match.group(2) ?? '';
        final uri = Uri.parse('bunker://$pubkey?$queryString');
        final relays = uri.queryParametersAll['relay'] ?? [];
        final secret = uri.queryParameters['secret'];

        if (pubkey.isEmpty || relays.isEmpty) {
          return null;
        }

        logger.i(secret);

        return BunkerPointer(
          pubkey: pubkey,
          relays: relays,
          secret: secret,
        );
      } catch (e) {
        return null;
      }
    }

    return null;
  }

  /// Create NostrConnect URI
  static String createNostrConnectURI(NostrConnectParams params) {
    if (params.clientPubkey.isEmpty) {
      throw ArgumentError('clientPubkey is required.');
    }
    if (params.relays.isEmpty) {
      throw ArgumentError('At least one relay is required.');
    }
    if (params.secret.isEmpty) {
      throw ArgumentError('secret is required.');
    }

    final queryParams = <String, String>{};

    if (params.image != null) queryParams['image'] = params.image!;
    if (params.url != null) queryParams['url'] = params.url!;
    if (params.name != null) queryParams['name'] = params.name!;

    queryParams['relay'] = params.relays.join('&');

    queryParams['secret'] = params.secret;

    if (params.perms != null && params.perms!.isNotEmpty) {
      queryParams['perms'] = params.perms!.join(',');
    }

    final uri = Uri(
      scheme: 'nostrconnect',
      host: params.clientPubkey,
      queryParameters: queryParams,
    );

    return uri.toString();
  }

  /// Parse NostrConnect URI
  static ParsedNostrConnectURI parseNostrConnectURI(String uri) {
    if (!uri.startsWith('nostrconnect://')) {
      throw ArgumentError(
          'Invalid nostrconnect URI: Must start with "nostrconnect://".');
    }

    final parsedUri = Uri.parse(uri);
    final clientPubkey = parsedUri.host;

    if (clientPubkey.isEmpty) {
      throw ArgumentError('Invalid nostrconnect URI: Missing client-pubkey.');
    }

    final relays = parsedUri.queryParametersAll['relay'] ?? [];
    if (relays.isEmpty) {
      throw ArgumentError(
          'Invalid nostrconnect URI: Missing "relay" parameter.');
    }

    final secret = parsedUri.queryParameters['secret'];
    if (secret == null || secret.isEmpty) {
      throw ArgumentError(
          'Invalid nostrconnect URI: Missing "secret" parameter.');
    }

    final permsString = parsedUri.queryParameters['perms'];
    final perms = permsString?.split(',');

    final params = NostrConnectParams(
      clientPubkey: clientPubkey,
      relays: relays,
      secret: secret,
      perms: perms,
      name: parsedUri.queryParameters['name'],
      url: parsedUri.queryParameters['url'],
      image: parsedUri.queryParameters['image'],
    );

    return ParsedNostrConnectURI(
      protocol: 'nostrconnect',
      clientPubkey: clientPubkey,
      params: params,
      originalString: uri,
    );
  }

  // Instance methods

  Future<void> _setupSubscription() async {
    if (!_isOpen) {
      await nc.connectNonConnectedRelays(relays.toSet());
      Set<String> processedIds = {};

      _subscriptionId = nc.addSubscription(
        [
          Filter(
            kinds: [EventKind.REMOTE_SIGNER],
            authors: [bunkerPubkey],
            p: [localSigner.publicKey],
          ),
        ],
        relays,
        eventCallBack: (event, relay) =>
            _handleSubscriptionEvent(event, relay, processedIds),
      );

      _isOpen = true;
    }
  }

  Future<String?> _decryptEventContent({
    required String content,
    required String pubkey,
  }) async {
    try {
      return (await localSigner.decrypt44(
            content,
            pubkey,
          )) ??
          (await localSigner.decrypt04(
            content,
            pubkey,
          ));
    } catch (e) {
      logger.i(e);
      return null;
    }
  }

  Future<void> _handleSubscriptionEvent(
    Event event,
    String relay,
    Set<String> processedIds,
  ) async {
    if (processedIds.contains(event.id)) return;
    processedIds.add(event.id);

    final decryptedContent = await _decryptEventContent(
      content: event.content,
      pubkey: bunkerPubkey,
    );

    if (decryptedContent == null) return;

    try {
      final data = json.decode(decryptedContent);

      final id = data['id'] as String?;

      final result = data['result'];
      final error = data['error'];

      if (result == 'auth_url' && id != null && _waitingForAuth[id] == true) {
        _waitingForAuth.remove(id);
        if (onAuth != null) {
          onAuth!(error ?? '', true);
        } else {
          logger.w(
              'Remote signer $bunkerPubkey tried to send auth_url but no onauth callback configured.');
        }
        return;
      }

      if (id != null && _listeners.containsKey(id)) {
        final completer = _listeners.remove(id)!;

        if (!completer.isCompleted) {
          if (error != null) {
            completer.completeError(error);
          } else {
            completer.complete(data);
          }
        }
      }
    } catch (e) {
      logger.e('Error processing subscription event: $e');
    }
  }

  Future<void> close() async {
    _isOpen = false;
    if (_subscriptionId != null) {
      nc.closeRequests([_subscriptionId!]);
      _subscriptionId = null;
    }
  }

  Future<Map<String, dynamic>> sendRequest(
    String method,
    List<String> params,
  ) async {
    final completer = Completer<Map<String, dynamic>>();

    if (_subscriptionId == null) {
      await _setupSubscription();
    }

    _serial++;
    final id = '$_idPrefix-$_serial';

    final requestData = {
      'id': id,
      'method': method,
      'params': params,
    };

    final encryptedContent = await localSigner.encrypt44(
      json.encode(requestData),
      bunkerPubkey,
    );

    if (encryptedContent == null) {
      completer.complete({
        'error': 'Failed to encrypt request',
      });
    }

    final event = await Event.genEvent(
      kind: EventKind.REMOTE_SIGNER,
      tags: [
        ['p', bunkerPubkey]
      ],
      content: encryptedContent!,
      signer: localSigner,
    );

    if (event == null) {
      completer.complete({
        'error': 'Failed to create request event',
      });
    }

    _listeners[id] = completer;
    _waitingForAuth[id] = true;

    // Send the event
    nc.sendEvent(event!, relays);

    // Setup timeout
    Timer(const Duration(seconds: 30), () {
      if (_listeners.containsKey(id)) {
        final comp = _listeners.remove(id)!;
        _waitingForAuth.remove(id);
        if (!comp.isCompleted) {
          comp.complete({
            'error': 'Request timed out',
          });
        }
      }
    });

    return completer.future;
  }

  /// Ping the bunker
  Future<void> ping() async {
    final response = await sendRequest('ping', []);
    final result = response['result'];
    if (result != 'pong') {
      logger.i('Result is not pong: $result');
    }
  }

  /// Connect to the bunker
  Future<bool> connect() async {
    _connectionState = RemoteSignerState.connecting;

    final data = await sendRequest(
      'connect',
      [bunkerPubkey, connectionSecret ?? '', perms.join(',')],
    );

    if (data['result'] == 'ack') {
      _connectionState = RemoteSignerState.connected;
      return true;
    }
    _connectionState = RemoteSignerState.failed;
    return false;
  }

  /// Get public key from bunker
  @override
  String getPublicKey() {
    return publicKey;
  }

  Future<String> getPublicKeyAsync() async {
    if (publicKey.isEmpty) {
      final response = await sendRequest('get_public_key', []);
      publicKey = response['result'] as String? ?? '';
    }

    return publicKey;
  }

  // EventSigner implementation

  @override
  bool canSign() => publicKey.isNotEmpty;

  @override
  bool isGuest() => false;

  @override
  Future<void> sign(Event event) async {
    final eventData = {
      'kind': event.kind,
      'content': event.content,
      'tags': event.tags,
      'created_at': event.createdAt,
    };

    final response = await sendRequest('sign_event', [json.encode(eventData)]);
    final result = response['result'];

    if (result != null) {
      final signedEvent = Event.fromString(result);
      if (signedEvent != null && signedEvent.kind == event.kind) {
        event.updateValuefromNewEvent(signedEvent);
      } else {
        logger.i('Event returned from bunker is improperly signed');
      }
    }
  }

  @override
  Future<String?> encrypt04(String msg, String destPubKey, {String? id}) async {
    final response = await sendRequest('nip04_encrypt', [destPubKey, msg]);
    return response['result'] as String?;
  }

  @override
  Future<String?> decrypt04(String msg, String destPubKey, {String? id}) async {
    final response = await sendRequest('nip04_decrypt', [destPubKey, msg]);
    return response['result'] as String?;
  }

  @override
  Future<String?> encrypt44(String msg, String destPubKey, {String? id}) async {
    final response = await sendRequest('nip44_encrypt', [destPubKey, msg]);
    return response['result'] as String?;
  }

  @override
  Future<String?> decrypt44(String msg, String destPubKey, {String? id}) async {
    final response = await sendRequest('nip44_decrypt', [destPubKey, msg]);
    return response['result'] as String?;
  }

  // Additional methods from your original implementation

  @override
  Future<Event?> encrypt04Event(
    String msg,
    String destPubKey, {
    String? id,
    String? replyId,
  }) async {
    final encryption = await encrypt04(msg, destPubKey);
    if (encryption != null) {
      return await Event.genEvent(
        kind: EventKind.DIRECT_MESSAGE,
        tags: Nip4.toTags(destPubKey, replyId ?? '', null),
        content: encryption,
        signer: this,
      );
    }
    return null;
  }

  @override
  Future<Event?> decrypt44Event(Event event, {String? id}) async {
    try {
      final sgString = await decrypt44(event.content, event.pubkey);
      if (sgString != null) {
        final sgEvent = Event.fromJson(
          json.decode(sgString),
          currentUser: publicKey,
        );

        final decrypt = await decrypt44(sgEvent.content, sgEvent.pubkey);
        if (decrypt != null) {
          return Event.fromJson(
            json.decode(decrypt),
            currentUser: publicKey,
          );
        }
      }
      return null;
    } catch (_) {
      return null;
    }
  }

  @override
  Future<Event?> encrypt44Event(
    Event event,
    String destPubKey, {
    String? id,
  }) async {
    final encode = json.encode(event.toJson());
    final encrypt = await encrypt44(encode, destPubKey);

    if (encrypt != null) {
      final ev = await Event.genEvent(
        kind: EventKind.SEALED_EVENT,
        content: encrypt,
        tags: [],
        signer: this,
      );

      if (ev != null) {
        return Nip59.encode(ev, destPubKey);
      }
    }
    return null;
  }

  // Helper methods

  void _loadSigner({
    required String secret,
    required List<String> relays,
    required String bunkerPubkey,
    required String publicKey,
    String? connectionSecret,
  }) {
    this.publicKey = publicKey;
    localSigner = Bip340EventSigner(secret, Keychain.getPublicKey(secret));
    this.bunkerPubkey = bunkerPubkey;
    this.relays = relays;
    this.connectionSecret = connectionSecret;
  }

  String _generateRandomId() {
    final random = Random();
    const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
    return String.fromCharCodes(
      Iterable.generate(
          7, (_) => chars.codeUnitAt(random.nextInt(chars.length))),
    );
  }

  // Serialization methods

  String toJson() {
    final data = {
      'secret': localSigner.privateKey,
      'relays': relays.join(','),
      'bunkerPubkey': bunkerPubkey,
      'publicKey': publicKey,
      'connectionSecret': connectionSecret,
    };
    return json.encode(data);
  }

  factory RemoteEventSigner.fromJson({
    required String jsonString,
    required Function(String, bool) onAuth,
    NostrCore? nc,
  }) {
    final decoded = json.decode(jsonString);
    final remote = RemoteEventSigner(onAuth: onAuth, nc: nc);

    remote._loadSigner(
      secret: decoded['secret'],
      relays: decoded['relays'].toString().split(','),
      bunkerPubkey: decoded['bunkerPubkey'],
      publicKey: decoded['publicKey'],
      connectionSecret: decoded['connectionSecret'],
    );

    return remote;
  }

  String getConnectionUrl() {
    final params = NostrConnectParams(
      clientPubkey: localSigner.publicKey,
      relays: relays,
      secret: connectionSecret ?? '',
      name: 'YakiHonne',
      url: 'https://yakihonne.com',
      image: '',
      perms: perms,
    );

    return createNostrConnectURI(params);
  }
}

const perms = [
  REMOTE_NIP04_DECRYPT,
  REMOTE_NIP04_ENCRYPT,
  REMOTE_NIP44_DECRYPT,
  REMOTE_NIP44_ENCRYPT,
  REMOTE_PUBLIC_KEY,
  PING,
  '$REMOTE_SIGN_EVENT:${EventKind.PUSH_CONFIG}',
  '$REMOTE_SIGN_EVENT:${EventKind.METADATA}',
  '$REMOTE_SIGN_EVENT:${EventKind.TEXT_NOTE}',
  '$REMOTE_SIGN_EVENT:${EventKind.REACTION}',
  '$REMOTE_SIGN_EVENT:${EventKind.REPOST}',
  '$REMOTE_SIGN_EVENT:${EventKind.LONG_FORM}',
  '$REMOTE_SIGN_EVENT:${EventKind.LONG_FORM_DRAFT}',
  '$REMOTE_SIGN_EVENT:${EventKind.CURATION_ARTICLES}',
  '$REMOTE_SIGN_EVENT:${EventKind.CURATION_VIDEOS}',
  '$REMOTE_SIGN_EVENT:${EventKind.VIDEO_HORIZONTAL}',
  '$REMOTE_SIGN_EVENT:${EventKind.VIDEO_VERTICAL}',
  '$REMOTE_SIGN_EVENT:${EventKind.VIDEO_VIEW}',
  '$REMOTE_SIGN_EVENT:${EventKind.APP_CUSTOM}',
  '$REMOTE_SIGN_EVENT:${EventKind.SMART_WIDGET_ENH}',
  '$REMOTE_SIGN_EVENT:${EventKind.CONTACT_LIST}',
  '$REMOTE_SIGN_EVENT:${EventKind.RELAY_LIST_METADATA}',
  '$REMOTE_SIGN_EVENT:${EventKind.AUTHENTICATION}',
  '$REMOTE_SIGN_EVENT:${EventKind.BLOSSOM_HTTP_AUTH}',
  '$REMOTE_SIGN_EVENT:${EventKind.BLOSSOM_SET}',
  '$REMOTE_SIGN_EVENT:${EventKind.EVENT_DELETION}',
  '$REMOTE_SIGN_EVENT:${EventKind.DM_RELAYS}',
  '$REMOTE_SIGN_EVENT:${EventKind.MUTE_LIST}',
  '$REMOTE_SIGN_EVENT:${EventKind.POLL}',
  '$REMOTE_SIGN_EVENT:${EventKind.INTEREST_SET}',
  '$REMOTE_SIGN_EVENT:${EventKind.HTTP_AUTH}',
  '$REMOTE_SIGN_EVENT:${EventKind.DVM_CONTENT_FEED}',
  '$REMOTE_SIGN_EVENT:${EventKind.FAVORITE_RELAYS}',
  '$REMOTE_SIGN_EVENT:${EventKind.CATEGORIZED_BOOKMARK}',
];
